/* The following code was generated by JFlex 1.4.3 on 3/3/15 4:08 PM */

/** Based on the arc lexer (http://code.google.com/p/intelli-arc/) **/

package com.r4intellij.lang.lexer;

import com.intellij.lexer.FlexLexer;
import com.intellij.psi.tree.IElementType;

import static com.r4intellij.psi.RTypes.*;

import com.intellij.util.containers.Stack;

/**
 * This class is a scanner generated by
 * <a href="http://www.jflex.de/">JFlex</a> 1.4.3
 * on 3/3/15 4:08 PM from the specification file
 * <tt>/Users/moon/Projects/git-projects/r4intellij/src/com/r4intellij/lang/lexer/r.flex</tt>
 */
public class _RLexer implements FlexLexer
{
	/**
	 * initial size of the lookahead buffer
	 */
	private static final int ZZ_BUFFERSIZE = 16384;

	/**
	 * lexical states
	 */
	public static final int YYINITIAL = 0;
	public static final int FUNCTION_CALL = 2;

	/**
	 * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
	 * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
	 * at the beginning of a line
	 * l is of the form l = 2*k, k a non negative integer
	 */
	private static final int ZZ_LEXSTATE[] = {
			0, 0, 1, 1
	};

	/**
	 * Translates characters to character classes
	 */
	private static final String ZZ_CMAP_PACKED =
			"\11\0\1\16\1\1\1\0\1\16\1\1\22\0\1\16\1\54\1\14" +
					"\1\2\1\70\1\65\1\60\1\15\1\46\1\47\1\64\1\11\1\45" +
					"\1\62\1\12\1\66\1\5\11\6\1\44\1\43\1\57\1\55\1\56" +
					"\1\73\1\72\4\3\1\10\6\3\1\7\1\3\1\41\5\3\1\71" +
					"\1\42\5\3\1\52\1\13\1\53\1\67\1\4\1\0\1\35\1\34" +
					"\1\22\1\3\1\32\1\17\1\3\1\30\1\24\1\3\1\36\1\31" +
					"\1\3\1\21\1\25\1\40\1\3\1\26\1\33\1\23\1\20\1\3" +
					"\1\27\1\37\2\3\1\50\1\61\1\51\1\63\uff81\0";

	/**
	 * Translates characters to character classes
	 */
	private static final char[] ZZ_CMAP = zzUnpackCMap( ZZ_CMAP_PACKED );

	/**
	 * Translates DFA states to action switch labels.
	 */
	private static final int[] ZZ_ACTION = zzUnpackAction();

	private static final String ZZ_ACTION_PACKED_0 =
			"\1\1\1\0\1\2\1\1\1\3\1\4\2\5\1\6" +
					"\1\4\2\7\1\10\10\4\1\11\1\12\1\13\1\14" +
					"\1\15\1\16\1\17\1\20\1\21\1\22\1\23\1\24" +
					"\1\25\1\26\1\27\1\30\1\31\1\32\1\33\1\34" +
					"\1\35\1\36\1\37\1\40\2\3\1\0\3\5\1\4" +
					"\3\7\3\4\1\41\1\42\5\4\1\43\1\44\1\45" +
					"\1\46\1\47\1\50\1\51\1\0\1\52\1\53\1\54" +
					"\1\55\3\0\1\33\1\3\1\5\1\0\1\4\1\56" +
					"\1\4\1\57\6\4\1\60\1\61\1\62\1\63\1\3" +
					"\1\5\1\4\1\64\2\4\1\65\1\4\1\66\1\3" +
					"\2\4\1\67\1\70\1\0\1\3\1\4\1\71\1\0" +
					"\1\3\1\4\1\72\1\3\1\73\160\3";

	private static int[] zzUnpackAction()
	{
		int[] result = new int[ 234 ];
		int offset = 0;
		offset = zzUnpackAction( ZZ_ACTION_PACKED_0, offset, result );
		return result;
	}

	private static int zzUnpackAction( String packed, int offset, int[] result )
	{
		int i = 0;       /* index in packed string  */
		int j = offset;  /* index in unpacked array */
		int l = packed.length();
		while ( i < l )
		{
			int count = packed.charAt( i++ );
			int value = packed.charAt( i++ );
			do
				result[ j++ ] = value; while ( --count > 0 );
		}
		return j;
	}

	/**
	 * Translates a state to a row index in the transition table
	 */
	private static final int[] ZZ_ROWMAP = zzUnpackRowMap();

	private static final String ZZ_ROWMAP_PACKED_0 =
			"\0\0\0\74\0\74\0\170\0\264\0\360\0\u012c\0\u0168" +
					"\0\74\0\u01a4\0\u01e0\0\u021c\0\u0258\0\u0294\0\u02d0\0\u030c" +
					"\0\u0348\0\u0384\0\u03c0\0\u03fc\0\u0438\0\74\0\u0474\0\74" +
					"\0\74\0\74\0\74\0\74\0\u04b0\0\u04ec\0\u0528\0\u0564" +
					"\0\u05a0\0\u05dc\0\u0618\0\u0654\0\u0690\0\74\0\74\0\u06cc" +
					"\0\74\0\74\0\74\0\74\0\74\0\u0708\0\u0744\0\u0780" +
					"\0\u07bc\0\74\0\u07f8\0\u0834\0\u0870\0\74\0\u08ac\0\u08e8" +
					"\0\u0924\0\u0960\0\360\0\360\0\u099c\0\u09d8\0\u0a14\0\u0a50" +
					"\0\u0a8c\0\u0ac8\0\74\0\74\0\74\0\74\0\74\0\74" +
					"\0\u0b04\0\74\0\74\0\74\0\u0b40\0\u0b7c\0\u0bb8\0\u0bf4" +
					"\0\74\0\u0c30\0\u0c6c\0\u0c6c\0\u0ca8\0\360\0\u0ce4\0\360" +
					"\0\u0d20\0\u0d5c\0\u0d98\0\u0dd4\0\u0e10\0\u0e4c\0\74\0\74" +
					"\0\74\0\74\0\u0e88\0\u0ec4\0\u0f00\0\360\0\u0f3c\0\u0f78" +
					"\0\360\0\u0fb4\0\360\0\u0ff0\0\u102c\0\u1068\0\360\0\360" +
					"\0\u10a4\0\u10e0\0\u111c\0\360\0\u1158\0\u1194\0\u11d0\0\u120c" +
					"\0\u1248\0\360\0\u1284\0\u12c0\0\u12fc\0\u1338\0\u1374\0\u13b0" +
					"\0\u13ec\0\u1428\0\u1464\0\u14a0\0\u14dc\0\u1518\0\u1554\0\u1590" +
					"\0\u15cc\0\u1608\0\u1644\0\u1680\0\u16bc\0\u16f8\0\u1734\0\u1770" +
					"\0\u17ac\0\u17e8\0\u1824\0\u1860\0\u189c\0\u18d8\0\u1914\0\u1950" +
					"\0\u198c\0\u19c8\0\u1a04\0\u1a40\0\u1a7c\0\u1ab8\0\u1af4\0\u1b30" +
					"\0\u1b6c\0\u1ba8\0\u1be4\0\u1c20\0\u1c5c\0\u1c98\0\u1cd4\0\u1d10" +
					"\0\u1d4c\0\u1d88\0\u1dc4\0\u1e00\0\u1e3c\0\u1e78\0\u1eb4\0\u1ef0" +
					"\0\u1f2c\0\u1f68\0\u1fa4\0\u1fe0\0\u201c\0\u2058\0\u2094\0\u20d0" +
					"\0\u210c\0\u2148\0\u2184\0\u21c0\0\u21fc\0\u2238\0\u2274\0\u22b0" +
					"\0\u22ec\0\u2328\0\u2364\0\u23a0\0\u23dc\0\u2418\0\u2454\0\u2490" +
					"\0\u24cc\0\u2508\0\u2544\0\u2580\0\u25bc\0\u25f8\0\u2634\0\u2670" +
					"\0\u26ac\0\u26e8\0\u2724\0\u2760\0\u279c\0\u27d8\0\u2814\0\u2850" +
					"\0\u288c\0\u28c8\0\u2904\0\u2940\0\u297c\0\u29b8\0\u29f4\0\u2a30" +
					"\0\u2a6c\0\u2aa8\0\u2ae4\0\u2b20\0\u2b5c\0\u2b98\0\u2bd4\0\u2c10" +
					"\0\u2c4c\0\u2c88";

	private static int[] zzUnpackRowMap()
	{
		int[] result = new int[ 234 ];
		int offset = 0;
		offset = zzUnpackRowMap( ZZ_ROWMAP_PACKED_0, offset, result );
		return result;
	}

	private static int zzUnpackRowMap( String packed, int offset, int[] result )
	{
		int i = 0;  /* index in packed string  */
		int j = offset;  /* index in unpacked array */
		int l = packed.length();
		while ( i < l )
		{
			int high = packed.charAt( i++ ) << 16;
			result[ j++ ] = high | packed.charAt( i++ );
		}
		return j;
	}

	/**
	 * The transition table of the DFA
	 */
	private static final int[] ZZ_TRANS = zzUnpackTrans();

	private static final String ZZ_TRANS_PACKED_0 =
			"\1\3\1\4\1\5\1\6\1\3\1\7\1\10\2\6" +
					"\1\11\1\12\1\3\1\13\1\14\1\15\1\16\1\6" +
					"\1\17\2\6\1\20\1\6\1\21\1\22\2\6\1\23" +
					"\1\6\1\24\4\6\1\25\1\6\1\26\1\27\1\30" +
					"\1\31\1\32\1\33\1\34\1\35\1\36\1\37\1\40" +
					"\1\41\1\42\1\43\1\44\1\45\1\46\1\47\1\50" +
					"\1\51\1\52\1\53\1\6\1\54\1\55\75\0\1\4" +
					"\72\0\1\56\1\0\1\57\71\56\3\0\6\6\1\0" +
					"\1\6\4\0\24\6\26\0\1\6\7\0\2\7\1\0" +
					"\1\60\1\0\1\61\17\0\1\60\46\0\2\10\1\62" +
					"\1\60\1\0\1\61\17\0\1\60\44\0\2\6\2\63" +
					"\2\6\1\0\1\64\4\0\24\6\26\0\1\6\2\0" +
					"\13\13\1\65\1\66\57\13\13\14\1\67\1\14\1\66" +
					"\56\14\16\0\1\15\60\0\6\6\1\0\1\6\4\0" +
					"\1\6\1\70\4\6\1\71\15\6\26\0\1\6\5\0" +
					"\6\6\1\0\1\6\4\0\13\6\1\72\10\6\26\0" +
					"\1\6\5\0\6\6\1\0\1\6\4\0\1\73\1\6" +
					"\1\74\21\6\26\0\1\6\5\0\6\6\1\0\1\6" +
					"\4\0\13\6\1\75\10\6\26\0\1\6\5\0\6\6" +
					"\1\0\1\6\4\0\11\6\1\76\12\6\26\0\1\6" +
					"\5\0\6\6\1\0\1\6\4\0\12\6\1\77\11\6" +
					"\26\0\1\6\5\0\6\6\1\0\1\6\4\0\7\6" +
					"\1\100\14\6\26\0\1\6\5\0\6\6\1\0\1\6" +
					"\4\0\23\6\1\101\26\0\1\6\46\0\1\102\101\0" +
					"\1\103\74\0\1\104\75\0\1\105\73\0\1\106\73\0" +
					"\1\107\73\0\1\110\1\0\1\111\2\0\1\112\71\0" +
					"\1\113\74\0\1\114\70\0\1\115\26\0\1\116\12\0" +
					"\1\117\1\116\11\0\1\116\16\0\1\116\1\120\4\0" +
					"\1\116\1\121\1\116\1\0\1\116\1\120\2\0\1\56" +
					"\1\0\73\56\1\0\1\122\71\56\5\0\2\123\2\0" +
					"\1\124\50\0\1\124\16\0\2\61\1\0\1\60\21\0" +
					"\1\60\44\0\2\6\2\63\1\6\1\125\1\0\1\6" +
					"\4\0\13\6\1\125\10\6\26\0\1\6\5\0\6\6" +
					"\1\0\1\126\4\0\24\6\26\0\1\6\2\0\1\13" +
					"\1\0\72\13\1\14\1\0\72\14\3\0\6\6\1\0" +
					"\1\6\4\0\2\6\1\127\21\6\26\0\1\6\5\0" +
					"\6\6\1\0\1\6\4\0\7\6\1\130\14\6\26\0" +
					"\1\6\5\0\6\6\1\0\1\6\4\0\20\6\1\131" +
					"\3\6\26\0\1\6\5\0\6\6\1\0\1\6\4\0" +
					"\21\6\1\132\2\6\26\0\1\6\5\0\6\6\1\0" +
					"\1\6\4\0\5\6\1\133\16\6\26\0\1\6\5\0" +
					"\6\6\1\0\1\6\4\0\14\6\1\134\7\6\26\0" +
					"\1\6\5\0\6\6\1\0\1\6\4\0\13\6\1\135" +
					"\10\6\26\0\1\6\5\0\4\6\1\136\1\6\1\0" +
					"\1\6\4\0\24\6\26\0\1\6\46\0\1\137\111\0" +
					"\1\140\67\0\1\141\102\0\1\142\27\0\1\116\130\0" +
					"\1\116\15\0\1\56\1\0\1\143\71\56\5\0\2\123" +
					"\70\0\2\6\2\144\2\6\1\124\1\6\4\0\24\6" +
					"\17\0\1\124\6\0\1\6\5\0\6\6\1\0\1\6" +
					"\4\0\3\6\1\145\20\6\26\0\1\6\5\0\6\6" +
					"\1\0\1\6\4\0\4\6\1\146\17\6\26\0\1\6" +
					"\5\0\6\6\1\0\1\6\4\0\13\6\1\147\10\6" +
					"\26\0\1\6\5\0\6\6\1\0\1\6\4\0\12\6" +
					"\1\150\11\6\26\0\1\6\5\0\6\6\1\0\1\6" +
					"\4\0\13\6\1\151\10\6\26\0\1\6\5\0\6\6" +
					"\1\0\1\6\4\0\16\6\1\152\5\6\26\0\1\6" +
					"\5\0\4\6\1\153\1\6\1\0\1\6\4\0\24\6" +
					"\26\0\1\6\2\0\1\56\1\0\1\154\71\56\3\0" +
					"\2\6\2\144\2\6\1\0\1\6\4\0\24\6\26\0" +
					"\1\6\5\0\6\6\1\0\1\6\4\0\4\6\1\155" +
					"\17\6\26\0\1\6\5\0\6\6\1\0\1\6\4\0" +
					"\16\6\1\156\5\6\26\0\1\6\5\0\6\6\1\0" +
					"\1\6\4\0\13\6\1\157\10\6\26\0\1\6\5\0" +
					"\6\6\1\0\1\6\4\0\17\6\1\160\4\6\26\0" +
					"\1\6\2\0\1\56\1\161\1\162\71\56\3\0\6\6" +
					"\1\0\1\6\4\0\5\6\1\163\16\6\26\0\1\6" +
					"\5\0\6\6\1\0\1\6\4\0\4\6\1\164\17\6" +
					"\26\0\1\6\4\0\1\165\71\0\1\56\1\161\1\166" +
					"\71\56\3\0\6\6\1\0\1\6\4\0\6\6\1\167" +
					"\15\6\26\0\1\6\4\0\1\170\71\0\1\56\1\161" +
					"\1\171\71\56\3\0\6\6\1\0\1\6\4\0\2\6" +
					"\1\172\21\6\26\0\1\6\2\0\1\170\1\0\72\170" +
					"\1\56\1\161\1\173\72\56\1\161\1\174\72\56\1\161" +
					"\1\175\72\56\1\161\1\176\72\56\1\161\1\177\72\56" +
					"\1\161\1\200\72\56\1\161\1\201\72\56\1\161\1\202" +
					"\72\56\1\161\1\203\72\56\1\161\1\204\72\56\1\161" +
					"\1\205\72\56\1\161\1\206\72\56\1\161\1\207\72\56" +
					"\1\161\1\210\72\56\1\161\1\211\72\56\1\161\1\212" +
					"\72\56\1\161\1\213\72\56\1\161\1\214\72\56\1\161" +
					"\1\215\72\56\1\161\1\216\72\56\1\161\1\217\72\56" +
					"\1\161\1\220\72\56\1\161\1\221\72\56\1\161\1\222" +
					"\72\56\1\161\1\223\72\56\1\161\1\224\72\56\1\161" +
					"\1\225\72\56\1\161\1\226\72\56\1\161\1\227\72\56" +
					"\1\161\1\230\72\56\1\161\1\231\72\56\1\161\1\232" +
					"\72\56\1\161\1\233\72\56\1\161\1\234\72\56\1\161" +
					"\1\235\72\56\1\161\1\236\72\56\1\161\1\237\72\56" +
					"\1\161\1\240\72\56\1\161\1\241\72\56\1\161\1\242" +
					"\72\56\1\161\1\243\72\56\1\161\1\244\72\56\1\161" +
					"\1\245\72\56\1\161\1\246\72\56\1\161\1\247\72\56" +
					"\1\161\1\250\72\56\1\161\1\251\72\56\1\161\1\252" +
					"\72\56\1\161\1\253\72\56\1\161\1\254\72\56\1\161" +
					"\1\255\72\56\1\161\1\256\72\56\1\161\1\257\72\56" +
					"\1\161\1\260\72\56\1\161\1\261\72\56\1\161\1\262" +
					"\72\56\1\161\1\263\72\56\1\161\1\264\72\56\1\161" +
					"\1\265\72\56\1\161\1\266\72\56\1\161\1\267\72\56" +
					"\1\161\1\270\72\56\1\161\1\271\72\56\1\161\1\272" +
					"\72\56\1\161\1\273\72\56\1\161\1\274\72\56\1\161" +
					"\1\275\72\56\1\161\1\276\72\56\1\161\1\277\72\56" +
					"\1\161\1\300\72\56\1\161\1\301\72\56\1\161\1\302" +
					"\72\56\1\161\1\303\72\56\1\161\1\304\72\56\1\161" +
					"\1\305\72\56\1\161\1\306\72\56\1\161\1\307\72\56" +
					"\1\161\1\310\72\56\1\161\1\311\72\56\1\161\1\312" +
					"\72\56\1\161\1\313\72\56\1\161\1\314\72\56\1\161" +
					"\1\315\72\56\1\161\1\316\72\56\1\161\1\317\72\56" +
					"\1\161\1\320\72\56\1\161\1\321\72\56\1\161\1\322" +
					"\72\56\1\161\1\323\72\56\1\161\1\324\72\56\1\161" +
					"\1\325\72\56\1\161\1\326\72\56\1\161\1\327\72\56" +
					"\1\161\1\330\72\56\1\161\1\331\72\56\1\161\1\332" +
					"\72\56\1\161\1\333\72\56\1\161\1\334\72\56\1\161" +
					"\1\335\72\56\1\161\1\336\72\56\1\161\1\337\72\56" +
					"\1\161\1\340\72\56\1\161\1\341\72\56\1\161\1\342" +
					"\72\56\1\161\1\343\72\56\1\161\1\344\72\56\1\161" +
					"\1\345\72\56\1\161\1\346\72\56\1\161\1\347\72\56" +
					"\1\161\1\350\72\56\1\161\1\351\72\56\1\161\1\352" +
					"\72\56\1\161\72\56";

	private static int[] zzUnpackTrans()
	{
		int[] result = new int[ 11460 ];
		int offset = 0;
		offset = zzUnpackTrans( ZZ_TRANS_PACKED_0, offset, result );
		return result;
	}

	private static int zzUnpackTrans( String packed, int offset, int[] result )
	{
		int i = 0;       /* index in packed string  */
		int j = offset;  /* index in unpacked array */
		int l = packed.length();
		while ( i < l )
		{
			int count = packed.charAt( i++ );
			int value = packed.charAt( i++ );
			value--;
			do
				result[ j++ ] = value; while ( --count > 0 );
		}
		return j;
	}

	/* error codes */
	private static final int ZZ_UNKNOWN_ERROR = 0;
	private static final int ZZ_NO_MATCH = 1;
	private static final int ZZ_PUSHBACK_2BIG = 2;
	private static final char[] EMPTY_BUFFER = new char[ 0 ];
	private static final int YYEOF = -1;
	private static java.io.Reader zzReader = null; // Fake

	/* error messages for the codes above */
	private static final String ZZ_ERROR_MSG[] = {
			"Unkown internal scanner error",
			"Error: could not match input",
			"Error: pushback value was too large"
	};

	/**
	 * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
	 */
	private static final int[] ZZ_ATTRIBUTE = zzUnpackAttribute();

	private static final String ZZ_ATTRIBUTE_PACKED_0 =
			"\1\1\1\10\1\11\5\1\1\11\14\1\1\11\1\1" +
					"\5\11\11\1\2\11\1\1\5\11\2\1\1\0\1\1" +
					"\1\11\3\1\1\11\14\1\6\11\1\0\3\11\1\1" +
					"\3\0\1\11\2\1\1\0\12\1\4\11\16\1\1\0" +
					"\3\1\1\0\165\1";

	private static int[] zzUnpackAttribute()
	{
		int[] result = new int[ 234 ];
		int offset = 0;
		offset = zzUnpackAttribute( ZZ_ATTRIBUTE_PACKED_0, offset, result );
		return result;
	}

	private static int zzUnpackAttribute( String packed, int offset, int[] result )
	{
		int i = 0;       /* index in packed string  */
		int j = offset;  /* index in unpacked array */
		int l = packed.length();
		while ( i < l )
		{
			int count = packed.charAt( i++ );
			int value = packed.charAt( i++ );
			do
				result[ j++ ] = value; while ( --count > 0 );
		}
		return j;
	}

	/**
	 * the current state of the DFA
	 */
	private int zzState;

	/**
	 * the current lexical state
	 */
	private int zzLexicalState = YYINITIAL;

	/**
	 * this buffer contains the current text to be matched and is
	 * the source of the yytext() string
	 */
	private CharSequence zzBuffer = "";

	/**
	 * this buffer may contains the current text array to be matched when it is cheap to acquire it
	 */
	private char[] zzBufferArray;

	/**
	 * the textposition at the last accepting state
	 */
	private int zzMarkedPos;

	/**
	 * the textposition at the last state to be included in yytext
	 */
	private int zzPushbackPos;

	/**
	 * the current text position in the buffer
	 */
	private int zzCurrentPos;

	/**
	 * startRead marks the beginning of the yytext() string in the buffer
	 */
	private int zzStartRead;

	/**
	 * endRead marks the last character in the buffer, that has been read
	 * from input
	 */
	private int zzEndRead;

	/**
	 * zzAtBOL == true <=> the scanner is currently at the beginning of a line
	 */
	private boolean zzAtBOL = true;

	/**
	 * zzAtEOF == true <=> the scanner is at the EOF
	 */
	private boolean zzAtEOF;

	/**
	 * denotes if the user-EOF-code has already been executed
	 */
	private boolean zzEOFDone;

  /* user code: */

	StringBuffer string = new StringBuffer();

	//helper
	long yychar = 0;

	public void goTo( int offset )
	{
		zzCurrentPos = zzMarkedPos = zzStartRead = offset;
		zzPushbackPos = 0;
		zzAtEOF = offset < zzEndRead;
	}

	public _RLexer( java.io.Reader in )
	{
		this.zzReader = in;
	}

	/**
	 * Creates a new scanner.
	 * There is also java.io.Reader version of this constructor.
	 * @param in the java.io.Inputstream to read input from.
	 */
	public _RLexer( java.io.InputStream in )
	{
		this( new java.io.InputStreamReader( in ) );
	}

	/**
	 * Unpacks the compressed character translation table.
	 * @param packed the packed character translation table
	 * @return the unpacked character translation table
	 */
	private static char[] zzUnpackCMap( String packed )
	{
		char[] map = new char[ 0x10000 ];
		int i = 0;  /* index in packed string  */
		int j = 0;  /* index in unpacked array */
		while ( i < 156 )
		{
			int count = packed.charAt( i++ );
			char value = packed.charAt( i++ );
			do
				map[ j++ ] = value; while ( --count > 0 );
		}
		return map;
	}

	public final int getTokenStart()
	{
		return zzStartRead;
	}

	public final int getTokenEnd()
	{
		return getTokenStart() + yylength();
	}

	public void reset( CharSequence buffer, int start, int end, int initialState )
	{
		zzBuffer = buffer;
		zzBufferArray = com.intellij.util.text.CharArrayUtil.fromSequenceWithoutCopying( buffer );
		zzCurrentPos = zzMarkedPos = zzStartRead = start;
		zzPushbackPos = 0;
		zzAtEOF = false;
		zzAtBOL = true;
		zzEndRead = end;
		yybegin( initialState );
	}

	/**
	 * Refills the input buffer.
	 * @return <code>false</code>, iff there was new input.
	 * @throws java.io.IOException if any I/O-Error occurs
	 */
	private boolean zzRefill() throws java.io.IOException
	{
		return true;
	}

	/**
	 * Returns the current lexical state.
	 */
	public final int yystate()
	{
		return zzLexicalState;
	}

	/**
	 * Enters a new lexical state
	 * @param newState the new lexical state
	 */
	public final void yybegin( int newState )
	{
		zzLexicalState = newState;
	}

	/**
	 * Returns the text matched by the current regular expression.
	 */
	public final CharSequence yytext()
	{
		return zzBuffer.subSequence( zzStartRead, zzMarkedPos );
	}

	/**
	 * Returns the character at position <tt>pos</tt> from the
	 * matched text.
	 *
	 * It is equivalent to yytext().charAt(pos), but faster
	 * @param pos the position of the character to fetch.
	 * A value from 0 to yylength()-1.
	 * @return the character at position pos
	 */
	public final char yycharat( int pos )
	{
		return zzBufferArray != null ? zzBufferArray[ zzStartRead + pos ] : zzBuffer.charAt( zzStartRead + pos );
	}

	/**
	 * Returns the length of the matched text region.
	 */
	public final int yylength()
	{
		return zzMarkedPos - zzStartRead;
	}

	/**
	 * Reports an error that occured while scanning.
	 *
	 * In a wellformed scanner (no or only correct usage of
	 * yypushback(int) and a match-all fallback rule) this method
	 * will only be called with things that "Can't Possibly Happen".
	 * If this method is called, something is seriously wrong
	 * (e.g. a JFlex bug producing a faulty scanner etc.).
	 *
	 * Usual syntax/scanner level error handling should be done
	 * in error fallback rules.
	 * @param errorCode the code of the errormessage to display
	 */
	private void zzScanError( int errorCode )
	{
		String message;
		try
		{
			message = ZZ_ERROR_MSG[ errorCode ];
		}
		catch ( ArrayIndexOutOfBoundsException e )
		{
			message = ZZ_ERROR_MSG[ ZZ_UNKNOWN_ERROR ];
		}

		throw new Error( message );
	}

	/**
	 * Pushes the specified amount of characters back into the input stream.
	 *
	 * They will be read again by then next call of the scanning method
	 * @param number the number of characters to be read again.
	 * This number must not be greater than yylength()!
	 */
	public void yypushback( int number )
	{
		if ( number > yylength() )
			zzScanError( ZZ_PUSHBACK_2BIG );

		zzMarkedPos -= number;
	}

	/**
	 * Contains user EOF-code, which will be executed exactly once,
	 * when the end of file is reached
	 */
	private void zzDoEOF()
	{
		if ( !zzEOFDone )
		{
			zzEOFDone = true;

		}
	}

	/**
	 * Resumes scanning until the next regular expression is matched,
	 * the end of input is encountered or an I/O-Error occurs.
	 * @return the next token
	 * @throws java.io.IOException if any I/O-Error occurs
	 */
	public IElementType advance() throws java.io.IOException
	{
		int zzInput;
		int zzAction;

		// cached fields:
		int zzCurrentPosL;
		int zzMarkedPosL;
		int zzEndReadL = zzEndRead;
		CharSequence zzBufferL = zzBuffer;
		char[] zzBufferArrayL = zzBufferArray;
		char[] zzCMapL = ZZ_CMAP;

		int[] zzTransL = ZZ_TRANS;
		int[] zzRowMapL = ZZ_ROWMAP;
		int[] zzAttrL = ZZ_ATTRIBUTE;

		while ( true )
		{
			zzMarkedPosL = zzMarkedPos;

			yychar += zzMarkedPosL - zzStartRead;

			zzAction = -1;

			zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;

			zzState = ZZ_LEXSTATE[ zzLexicalState ];

			zzForAction:
			{
				while ( true )
				{

					if ( zzCurrentPosL < zzEndReadL )
						zzInput = zzBufferArrayL != null ? zzBufferArrayL[ zzCurrentPosL++ ] : zzBufferL.charAt( zzCurrentPosL++ );
					else if ( zzAtEOF )
					{
						zzInput = YYEOF;
						break zzForAction;
					}
					else
					{
						// store back cached positions
						zzCurrentPos = zzCurrentPosL;
						zzMarkedPos = zzMarkedPosL;
						boolean eof = zzRefill();
						// get translated positions and possibly new buffer
						zzCurrentPosL = zzCurrentPos;
						zzMarkedPosL = zzMarkedPos;
						zzBufferL = zzBuffer;
						zzEndReadL = zzEndRead;
						if ( eof )
						{
							zzInput = YYEOF;
							break zzForAction;
						}
						else
						{
							zzInput = zzBufferArrayL != null ? zzBufferArrayL[ zzCurrentPosL++ ] : zzBufferL.charAt( zzCurrentPosL++ );
						}
					}
					int zzNext = zzTransL[ zzRowMapL[ zzState ] + zzCMapL[ zzInput ] ];
					if ( zzNext == -1 )
						break zzForAction;
					zzState = zzNext;

					int zzAttributes = zzAttrL[ zzState ];
					if ( ( zzAttributes & 1 ) == 1 )
					{
						zzAction = zzState;
						zzMarkedPosL = zzCurrentPosL;
						if ( ( zzAttributes & 8 ) == 8 )
							break zzForAction;
					}

				}
			}

			// store back cached position
			zzMarkedPos = zzMarkedPosL;

			switch ( zzAction < 0 ? zzAction : ZZ_ACTION[ zzAction ] )
			{
				case 46:
				{
					return R_SYMBOL_FORMALS;
				}
				case 60:
					break;
				case 42:
				{
					return R_LEFT_ASSIGN;
				}
				case 61:
					break;
				case 14:
				{
					return R_LEFT_BRACE;
				}
				case 62:
					break;
				case 47:
				{
					return R_FOR;
				}
				case 63:
					break;
				case 54:
				{
					return R_NULL_CONST;
				}
				case 64:
					break;
				case 57:
				{
					return R_REPEAT;
				}
				case 65:
					break;
				case 27:
				{
					return R_ARITH_MOD;
				}
				case 66:
					break;
				case 24:
				{
					return R_ARITH_MINUS;
				}
				case 67:
					break;
				case 31:
				{
					return R_SLOT;
				}
				case 68:
					break;
				case 19:
				{
					return R_EQ_ASSIGN;
				}
				case 69:
					break;
				case 23:
				{
					return R_OR;
				}
				case 70:
					break;
				case 34:
				{
					return R_IN;
				}
				case 71:
					break;
				case 3:
				{
					return R_COMMENT;
				}
				case 72:
					break;
				case 48:
				{
					return R_NS_GET_INT;
				}
				case 73:
					break;
				case 43:
				{
					return R_AND2;
				}
				case 74:
					break;
				case 28:
				{
					return R_ARITH_DIV;
				}
				case 75:
					break;
				case 25:
				{
					return R_TILDE;
				}
				case 76:
					break;
				case 36:
				{
					return R_LBB;
				}
				case 77:
					break;
				case 49:
				{
					return R_GLOBAL_LEFT_ASSIGN;
				}
				case 78:
					break;
				case 58:
				{
					return R_SECTION_COMMENT;
				}
				case 79:
					break;
				case 17:
				{
					return R_RIGHT_BRACKET;
				}
				case 80:
					break;
				case 40:
				{
					return R_GE;
				}
				case 81:
					break;
				case 53:
				{
					return R_ELSE;
				}
				case 82:
					break;
				case 45:
				{
					return R_RIGHT_ASSIGN;
				}
				case 83:
					break;
				case 11:
				{
					return R_COMMA;
				}
				case 84:
					break;
				case 20:
				{
					return R_GT;
				}
				case 85:
					break;
				case 6:
				{
					return R_ARITH_PLUS;
				}
				case 86:
					break;
				case 32:
				{
					return R_QUESTION;
				}
				case 87:
					break;
				case 38:
				{
					return R_NE;
				}
				case 88:
					break;
				case 51:
				{
					return R_ARITH_MISC;
				}
				case 89:
					break;
				case 35:
				{
					return R_NS_GET;
				}
				case 90:
					break;
				case 52:
				{
					return R_NEXT;
				}
				case 91:
					break;
				case 10:
				{
					return R_COLON;
				}
				case 92:
					break;
				case 30:
				{
					return R_LIST_SUBSET;
				}
				case 93:
					break;
				case 1:
				{
					return R_EOL;
				}
				case 94:
					break;
				case 59:
				{
					return R_FUNCTION;
				}
				case 95:
					break;
				case 13:
				{
					return R_RIGHT_PAREN;
				}
				case 96:
					break;
				case 39:
				{
					return R_EQ;
				}
				case 97:
					break;
				case 22:
				{
					return R_AND;
				}
				case 98:
					break;
				case 16:
				{
					return R_LEFT_BRACKET;
				}
				case 99:
					break;
				case 37:
				{
					return R_RBB;
				}
				case 100:
					break;
				case 18:
				{
					return R_NEGATION;
				}
				case 101:
					break;
				case 12:
				{
					return R_LEFT_PAREN;
				}
				case 102:
					break;
				case 9:
				{
					return R_SEMICOLON;
				}
				case 103:
					break;
				case 26:
				{
					return R_ARITH_MULT;
				}
				case 104:
					break;
				case 41:
				{
					return R_LE;
				}
				case 105:
					break;
				case 33:
				{
					return R_IF;
				}
				case 106:
					break;
				case 8:
				{
					return com.intellij.psi.TokenType.WHITE_SPACE;
				}
				case 107:
					break;
				case 44:
				{
					return R_OR2;
				}
				case 108:
					break;
				case 21:
				{
					return R_LT;
				}
				case 109:
					break;
				case 55:
				{
					return R_WHILE;
				}
				case 110:
					break;
				case 29:
				{
					return R_ARITH_EXPONENTIAION;
				}
				case 111:
					break;
				case 15:
				{
					return R_RIGHT_BRACE;
				}
				case 112:
					break;
				case 5:
				{
					return R_NUM_CONST;
				}
				case 113:
					break;
				case 50:
				{
					return R_GLOBAL_RIGHT_ASSIGN;
				}
				case 114:
					break;
				case 56:
				{
					return R_BREAK;
				}
				case 115:
					break;
				case 7:
				{
					return R_STR_CONST;
				}
				case 116:
					break;
				case 2:
				{
					return com.intellij.psi.TokenType.BAD_CHARACTER;
				}
				case 117:
					break;
				case 4:
				{
					return R_SYMBOL;
				}
				case 118:
					break;
				default:
					if ( zzInput == YYEOF && zzStartRead == zzCurrentPos )
					{
						zzAtEOF = true;
						zzDoEOF();
						return null;
					}
					else
					{
						zzScanError( ZZ_NO_MATCH );
					}
			}
		}
	}

}
